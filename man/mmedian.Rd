% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mmedian.R
\name{mmedian}
\alias{mmedian}
\title{Median of multidimensional data}
\usage{
mmedian(x, na.rm = FALSE, metric = "euclidean", q = 3, simple1d = TRUE,
  ...)
}
\arguments{
\item{x}{a matrix, data frame or vector of data points (a vector will be understood as 1D data, equivalent to a 1-column matrix). Rows with NA values will be dropped.}

\item{na.rm}{boolean, whether or not to drop rows (or elements, if 1D vector) in \code{x} that contain NAs.}

\item{metric}{a choice of 'euclidean','maximum','manhattan','canberra','minkowski', or 'binary'. Can be abbreviated to first three letters, case-insensitive.}

\item{q}{the power in the minkowski metric. If \code{q=2}, equivalent to 'euclidean'.}

\item{simple1d}{boolean, if TRUE, will resort to the standard \code{median} function in case the data is 1D. This means that only euclidean metric will be used. However, most metrics are identical to euclidean in 1D anyway, so it is usually no big loss.}

\item{...}{other arguments passed to \code{Rcgmin::Rcgmin}.}
}
\value{
a vector of median components.
}
\description{
Median of multidimensional data
}
\details{
The median is calculated as the minimizer m of the sum of distances ||x_i-m||, where x_i are the data points.
In an N-dimensional space, each x_i is an N-dimensional vector, and so is m.
The distances are calculated according to the metric chosen (Euclidean by default). Minimization is done with \code{Rcgmin} (note that exotic metrics you might cause convergence issues).
In 1D case, unless \code{simple1d} is FALSE, the standard \code{median} function is used instead of this method.
}
